diff --git a/api/include/opentelemetry/common/macros.h b/api/include/opentelemetry/common/macros.h
index 71d12a5..6020c59 100644
--- a/api/include/opentelemetry/common/macros.h
+++ b/api/include/opentelemetry/common/macros.h
@@ -521,3 +521,16 @@ point.
 #else
 #  define OPENTELEMETRY_SANITIZER_NO_ADDRESS
 #endif
+
+// ====== Patch for GCC 4.8 ======
+#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ == 4) && (__GNUC_MINOR__ == 8)
+#include <memory>
+namespace std
+{
+template <class T, class... ArgsT>
+unique_ptr<T> make_unique(ArgsT &&...args)
+{
+  return unique_ptr<T>(new T(std::forward<ArgsT>(args)...));
+}
+}  // namespace std
+#endif
diff --git a/api/include/opentelemetry/nostd/type_traits.h b/api/include/opentelemetry/nostd/type_traits.h
index a797c1e..3134e01 100644
--- a/api/include/opentelemetry/nostd/type_traits.h
+++ b/api/include/opentelemetry/nostd/type_traits.h
@@ -20,7 +20,7 @@
 #endif
 
 #if !defined(__GLIBCXX__) || (defined(_GLIBCXX_RELEASE) && _GLIBCXX_RELEASE >= 7) || \
-    (defined(__GLIBCXX__) && __GLIBCXX__ >= 20150422)  // >= libstdc++-5
+    (defined(__GLIBCXX__) && __GLIBCXX__ >= 20150422 && (!defined(__GNUC__) || __GNUC__ >= 5))  // >= libstdc++-5
 #  define OPENTELEMETRY_TRIVIALITY_TYPE_TRAITS
 #endif
 
diff --git a/exporters/otlp/src/otlp_file_client.cc b/exporters/otlp/src/otlp_file_client.cc
index dab2128..6f0e6af 100644
--- a/exporters/otlp/src/otlp_file_client.cc
+++ b/exporters/otlp/src/otlp_file_client.cc
@@ -1234,8 +1234,6 @@ class OPENTELEMETRY_LOCAL_SYMBOL OtlpFileSystemBackend : public OtlpFileAppender
     }
     file_path[file_path_size] = 0;
 
-    std::shared_ptr<FILE> of = std::make_shared<FILE>();
-
     std::string directory_name = FileSystemUtil::DirName(file_path);
     if (!directory_name.empty())
     {
@@ -1290,7 +1288,7 @@ class OPENTELEMETRY_LOCAL_SYMBOL OtlpFileSystemBackend : public OtlpFileAppender
                               << " failed with pattern: " << options_.file_pattern << hint);
       return nullptr;
     }
-    of = std::shared_ptr<std::FILE>(new_file, fclose);
+    std::shared_ptr<FILE> of = std::shared_ptr<std::FILE>(new_file, fclose);
 
     fseek(of.get(), 0, SEEK_END);
     file_->written_size = static_cast<size_t>(ftell(of.get()));
diff --git a/ext/include/opentelemetry/ext/http/client/curl/http_operation_curl.h b/ext/include/opentelemetry/ext/http/client/curl/http_operation_curl.h
index 2c35651..8d30215 100644
--- a/ext/include/opentelemetry/ext/http/client/curl/http_operation_curl.h
+++ b/ext/include/opentelemetry/ext/http/client/curl/http_operation_curl.h
@@ -338,7 +338,7 @@ class HttpOperation
   {
     Session *session;  // Owner Session
 
-    std::thread::id callback_thread;
+    OPENTELEMETRY_SANITIZER_NO_THREAD std::thread::id callback_thread;
     std::function<void(HttpOperation &)> callback;
     std::atomic<bool> is_promise_running{false};
     std::promise<CURLcode> result_promise;
diff --git a/sdk/src/logs/multi_log_record_processor.cc b/sdk/src/logs/multi_log_record_processor.cc
index 1841a75..1960042 100644
--- a/sdk/src/logs/multi_log_record_processor.cc
+++ b/sdk/src/logs/multi_log_record_processor.cc
@@ -73,39 +73,33 @@ void MultiLogRecordProcessor::OnEmit(std::unique_ptr<Recordable> &&record) noexc
 
 bool MultiLogRecordProcessor::ForceFlush(std::chrono::microseconds timeout) noexcept
 {
-  // Convert to nanos to prevent overflow
-  std::chrono::nanoseconds timeout_ns = std::chrono::nanoseconds::max();
-  if (std::chrono::duration_cast<std::chrono::microseconds>(timeout_ns) > timeout)
-  {
-    timeout_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(timeout);
-  }
   bool result           = true;
   auto start_time       = std::chrono::system_clock::now();
   auto overflow_checker = std::chrono::system_clock::time_point::max();
   std::chrono::system_clock::time_point expire_time;
-  if (overflow_checker - start_time <= timeout_ns)
+  if (std::chrono::duration_cast<std::chrono::microseconds>(overflow_checker - start_time) <= timeout)
   {
     expire_time = overflow_checker;
   }
   else
   {
     expire_time =
-        start_time + std::chrono::duration_cast<std::chrono::system_clock::duration>(timeout_ns);
+        start_time + std::chrono::duration_cast<std::chrono::system_clock::duration>(timeout);
   }
   for (auto &processor : processors_)
   {
-    if (!processor->ForceFlush(std::chrono::duration_cast<std::chrono::microseconds>(timeout_ns)))
+    if (!processor->ForceFlush(timeout))
     {
       result = false;
     }
     start_time = std::chrono::system_clock::now();
     if (expire_time > start_time)
     {
-      timeout_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(expire_time - start_time);
+      timeout = std::chrono::duration_cast<std::chrono::microseconds>(expire_time - start_time);
     }
     else
     {
-      timeout_ns = std::chrono::nanoseconds::zero();
+      timeout = std::chrono::microseconds::zero();
     }
   }
   return result;
@@ -113,37 +107,31 @@ bool MultiLogRecordProcessor::ForceFlush(std::chrono::microseconds timeout) noex
 
 bool MultiLogRecordProcessor::Shutdown(std::chrono::microseconds timeout) noexcept
 {
-  // Converto nanos to prevent overflow
-  std::chrono::nanoseconds timeout_ns = std::chrono::nanoseconds::max();
-  if (std::chrono::duration_cast<std::chrono::microseconds>(timeout_ns) > timeout)
-  {
-    timeout_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(timeout);
-  }
   bool result           = true;
   auto start_time       = std::chrono::system_clock::now();
   auto overflow_checker = std::chrono::system_clock::time_point::max();
   std::chrono::system_clock::time_point expire_time;
-  if (overflow_checker - start_time <= timeout_ns)
+  if (std::chrono::duration_cast<std::chrono::microseconds>(overflow_checker - start_time) <= timeout)
   {
     expire_time = overflow_checker;
   }
   else
   {
     expire_time =
-        start_time + std::chrono::duration_cast<std::chrono::system_clock::duration>(timeout_ns);
+        start_time + std::chrono::duration_cast<std::chrono::system_clock::duration>(timeout);
   }
   for (auto &processor : processors_)
   {
     result |=
-        processor->Shutdown(std::chrono::duration_cast<std::chrono::microseconds>(timeout_ns));
+        processor->Shutdown(timeout);
     start_time = std::chrono::system_clock::now();
     if (expire_time > start_time)
     {
-      timeout_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(expire_time - start_time);
+      timeout = std::chrono::duration_cast<std::chrono::microseconds>(expire_time - start_time);
     }
     else
     {
-      timeout_ns = std::chrono::nanoseconds::zero();
+      timeout = std::chrono::microseconds::zero();
     }
   }
   return result;
